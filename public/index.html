<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FÃ¶rderFunke</title>
    <script src="./bundle.js"></script>
    <link rel="stylesheet" href="./choices.min.css" />
    <script src="./choices.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .loadingDiv {
            color: gray;
        }
    </style>
</head>
<body>
    <div id="update-banner" style="display: none; width: 100%; background-color: lightblue; color: darkblue; padding: 5px; text-align: center;">
        Update available, reload the page to get the latest version.
    </div>
    <h3>User profile</h3>
    <div id="userProfileDiv"></div>
    <br/>
    <small><a href="#" onclick="clearUserProfile()">Reset</a></small> <small><a href="#" onclick="downloadUserProfileTurtle()">Export</a></small>
    <h3>Missing data points</h3>
    <div>Set a focus:</div>
    <br/>
    <select id="focusInputSelectElement" multiple></select>
    <div class="loadingDiv">Loading...</div>
    <div id="missingDataPointsDiv"></div>
    <h3>Report</h3>
    <div class="loadingDiv">Loading...</div>
    <table id="reportTable"></table>

    <script>
        const element = document.getElementById("focusInputSelectElement")
        const focusInputSelect = new Choices(element, {
            removeItemButton: true,
            position: "bottom"
        });

        focusInputSelect.passedElement.element.addEventListener("addItem", async function() {
            focusInputSelect.hideDropdown()
            await buildPrioritizedMissingDataList()
        }, false)

        focusInputSelect.passedElement.element.addEventListener("removeItem", async function() {
            await buildPrioritizedMissingDataList()
        }, false)

        let latestRPsRepoCommit
        let userProfile
        let turtleMap
        let metadata
        let validateAllReport
        let eligibleRPs

        async function fetchTextFile(relPath) {
            const response = await fetch(relPath)
            return await response.text()
        }

        async function parseTurtleFiles() {
            turtleMap = {
                "datafields": await fetchTextFile("requirement-profiles/datafields.ttl"),
                "materialization": await fetchTextFile("requirement-profiles/materialization.ttl"),
                "shacl": {}
            }
            let shaclFiles = await fetchTextFile("shacl-files.txt")
            for (let filename of shaclFiles.split("\n")) {
                if (!filename) continue
                turtleMap.shacl[filename] = await fetchTextFile("requirement-profiles/shacl/" + filename)
            }
            metadata = {
                df: await MatchingEngine.extractDatafieldsMetadata(turtleMap.datafields),
                rp: await MatchingEngine.extractRequirementProfilesMetadata(Object.values(turtleMap.shacl))
            }
            console.log("metadata", metadata)
        }

        async function checkForUpdates() {
            console.log("Checking for updates, old commit:", latestRPsRepoCommit)
            let checkLatestRPsRepoCommit = await fetchTextFile("latest-rps-repo-commit.txt")
            if (checkLatestRPsRepoCommit === latestRPsRepoCommit) return
            console.log("Update available, new commit:", checkLatestRPsRepoCommit)
            latestRPsRepoCommit = checkLatestRPsRepoCommit
            document.getElementById("update-banner").style.display = "block"
            let eligibleRPsBefore = [... eligibleRPs]
            await parseTurtleFiles()
            await validateAll()
            let newEligibleRPs = eligibleRPs.filter(rp => !eligibleRPsBefore.includes(rp))
            if (newEligibleRPs.length > 0) {
                alert("New eligible requirement profiles available: " + newEligibleRPs.map(rpUri => getRpTitle(rpUri)).join(", "))
            }
        }

        function getRpTitle(rpUri) {
            return metadata.rp[rpUri]?.title ?? rpUri
        }

        function buildFocusInputSelectChoices() {
            let categories = {}
            let rps = []
            for (let rp of Object.values(metadata.rp)) {
                rps.push({
                    value: rp.uri,
                    label: rp.title,
                })
                for (let cat of rp.categories) {
                    if (!categories[cat]) categories[cat] = []
                    categories[cat].push(rp.uri)
                }
            }
            metadata.categories = categories
            focusInputSelect.setChoices([
                {
                    label: "Categories",
                    choices: Object.keys(categories).map(uri => {
                        return {
                            value: uri,
                            label: uri.split("#")[1],
                        }
                    })
                },
                {
                    label: "Requirement Profiles",
                    choices: rps
                },
            ])
        }

        async function validateAll() {
            await buildProfile()

            let userProfileTurtle = await MatchingEngine.convertUserProfileToTurtle(userProfile)
            console.log("userProfileTurtle", userProfileTurtle)
            validateAllReport = await MatchingEngine.validateAll(userProfileTurtle, turtleMap.shacl, turtleMap.datafields, turtleMap.materialization)
            console.log("validateAllReport", validateAllReport)

            let tableEl = document.getElementById("reportTable")
            tableEl.textContent = ""
            eligibleRPs = []

            for (let report of validateAllReport.reports) {
                if (report.result === "eligible") {
                    eligibleRPs.push(report.rpUri)
                }
                let tr = document.createElement("tr")
                let td = document.createElement("td")
                td.textContent = getRpTitle(report.rpUri)
                if (!metadata.rp[report.rpUri] || metadata.rp[report.rpUri].categories.length === 0) {
                    td.title = "No category info available"
                } else {
                    td.title = metadata.rp[report.rpUri].categories.map(cat => cat.split("#")[1]).join("\n")
                }
                tr.appendChild(td)
                td = document.createElement("td")
                td.textContent = report.result
                switch (report.result) {
                    case "eligible":
                        td.style.color = "green"
                        td.style.fontWeight = "bold"
                        break
                    case "ineligible":
                        td.style.color = "red"
                        break
                    case "undeterminable":
                        td.style.color = "gray"
                        break
                }
                let msg = ""
                switch (report.result) {
                    case "eligible":
                        if (report.inMemoryMaterializedTriples.length > 0) {
                            msg += "Inferred data points:\n"
                        }
                        for (let triple of report.inMemoryMaterializedTriples) {
                            msg += "- " + (metadata.df[triple.p] ? metadata.df[triple.p].label : triple.p.split("#")[1])
                        }
                        break
                    case "ineligible":
                        for (let violation of report.violations) {
                            msg += violation.message + "\n"
                        }
                        break
                    case "undeterminable":
                        msg += "Missing data points:\n"
                        for (let missing of report.missingUserInput) {
                            if (metadata.df[missing.dfUri]) {
                                msg += "- " + metadata.df[missing.dfUri].label + "\n"
                            }
                        }
                        break
                }
                td.title = msg
                tr.appendChild(td)
                tableEl.appendChild(tr)
            }

            await buildPrioritizedMissingDataList()
        }

        async function buildPrioritizedMissingDataList() {
            let div = document.getElementById("missingDataPointsDiv")
            div.textContent = ""
            let prioritizedList = []

            let missingData = validateAllReport.missingUserInputsAggregated

            let focusRPs = []
            for (let focusItem of focusInputSelect.getValue(true)) {
                if (metadata.categories[focusItem]) {
                    focusRPs = focusRPs.concat(metadata.categories[focusItem])
                } else {
                    focusRPs.push(focusItem)
                }
            }

            for (let key of Object.keys(missingData)) {
                let datafield = missingData[key]

                let usedInRpUris = datafield.usedIn.map(usedInRP => usedInRP.rpUri)
                if (focusRPs.length > 0 && !usedInRpUris.some(rpUri => focusRPs.includes(rpUri))) {
                    continue
                }

                let usedInTitles = []
                let lastMissingCounter = 0
                for (let usedInRP of datafield.usedIn) {
                    usedInTitles.push(metadata.rp[usedInRP.rpUri].title + (usedInRP.isLastMissingUserInput ? " (!)" : ""))
                    if (usedInRP.isLastMissingUserInput) lastMissingCounter += 1
                }
                prioritizedList.push({
                    dfUri: datafield.dfUri,
                    objectHasClass: metadata.df[datafield.dfUri]?.objectHasClass,
                    label: metadata.df[datafield.dfUri]?.label ?? datafield.dfUri.split("#")[1],
                    score: datafield.usedIn.length + lastMissingCounter,
                    usedInTitles: usedInTitles
                })
            }
            prioritizedList.sort((a, b) => b.score - a.score)
            prioritizedList.forEach((entry) => {
                let spanEl = document.createElement("span")
                spanEl.title = entry.usedInTitles.join("\n")
                spanEl.style.color = "gray"
                let textNode = document.createTextNode(entry.score + ": ")
                spanEl.appendChild(textNode)
                div.appendChild(spanEl)
                let a = document.createElement("a")
                a.href = "#"
                a.textContent = entry.label
                a.addEventListener("click", async function(event) {
                    event.preventDefault()
                    // if (entry.objectHasClass) {
                    //    let input = prompt("How many " + entry.objectHasClass.split("#")[1] + " do you have?")
                    // }
                    let input = prompt("What is your value for: " + entry.label)
                    if (input !== null) {
                        console.log(entry.dfUri, "-->", input)
                        await addProfileEntry(entry.dfUri, input)
                    }
                });
                div.appendChild(a)
                div.appendChild(document.createElement("br"))
            });
            for (const elem of Array.from(document.getElementsByClassName("loadingDiv"))) {
                elem.style.display = "none"
            }
        }

        async function addProfileEntry(dfUri, value) {
            let key = "ff:" + dfUri.split("#")[1]
            let result = await MatchingEngine.validateSingleDatafieldValue({ [key]: value }, turtleMap.datafields)
            if (!result.conforms) {
                let msgs = "\n"
                for (let violation of result.violations) {
                    msgs += violation.message + "\n"
                }
                alert(value + " is an invalid input for " + metadata.df[dfUri].label + ": " + msgs)
                return
            }
            userProfile[key] = value
            console.log("userProfile", userProfile)
            localStorage.setItem("userProfile", JSON.stringify(userProfile))
            await validateAll()
        }

        async function buildProfile() {
            let div = document.getElementById("userProfileDiv")
            div.innerHTML = ""
            let table = document.createElement("table")
            div.appendChild(table)

            for (let [key, value] of Object.entries(userProfile)) {
                let keyShort = key
                if (key.startsWith("ff:")) key = "https://foerderfunke.org/default#" + key.slice(3)
                let tr = document.createElement("tr")
                table.appendChild(tr)
                let td = document.createElement("td")
                td = document.createElement("td")
                td.textContent = metadata.df[key].label + ": "
                td.style.color = "gray"
                td.title = key
                tr.appendChild(td)
                td = document.createElement("td")
                td.textContent = value
                td.style.textDecoration = "underline"
                td.addEventListener("click", async function() {
                    let input = prompt("Enter new value for: " + metadata.df[key].label)
                    if (input !== null) {
                        console.log(key, "-->", input)
                        await addProfileEntry(key, input)
                    }
                })
                tr.appendChild(td)
                td = document.createElement("td")
                td.textContent = "x"
                td.style.color = "gray"
                td.style.fontSize = "small"
                td.addEventListener("click", async function() {
                    delete userProfile[keyShort]
                    localStorage.setItem("userProfile", JSON.stringify(userProfile))
                    await validateAll()
                })
                tr.appendChild(td)
            }
        }

        async function clearUserProfile() {
            localStorage.clear()
            userProfile = {}
            localStorage.setItem("userProfile", JSON.stringify(userProfile));
            await validateAll()
        }

        async function downloadUserProfileTurtle() {
            let userProfileTurtle = await MatchingEngine.convertUserProfileToTurtle(userProfile)
            let blob = new Blob([userProfileTurtle], {type: "text/turtle"})
            let url = URL.createObjectURL(blob)
            let a = document.createElement("a")
            a.href = url
            a.download = "user-profile.ttl"
            document.body.appendChild(a)
            a.click()
            document.body.removeChild(a)
            window.URL.revokeObjectURL(url)
        }

        async function run() {
            if (localStorage.getItem("userProfile") === null) {
                localStorage.setItem("userProfile", JSON.stringify({}));
            }
            userProfile = JSON.parse(localStorage.getItem("userProfile"))

            latestRPsRepoCommit = await fetchTextFile("latest-rps-repo-commit.txt")
            await parseTurtleFiles()
            buildFocusInputSelectChoices()
            await validateAll()
            setInterval(checkForUpdates, 10 * 1000)
        }

        run()

    </script>
</body>
</html>
