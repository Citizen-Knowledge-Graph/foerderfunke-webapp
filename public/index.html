<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FÃ¶rderFunke</title>
    <script src="./bundle.js"></script>
    <link rel="stylesheet" href="./choices.min.css" />
    <script src="./choices.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .loadingDiv {
            color: gray;
        }
        .framed-table {
            border: 1px solid silver;
            border-collapse: collapse;
        }
        .framed-table th, .framed-table td {
            border: 1px solid silver;
            padding: 8px;
        }
    </style>
</head>
<body>
    <div id="update-banner" style="display: none; width: 100%; background-color: lightblue; color: darkblue; padding: 5px; text-align: center;">
        Update available, reload the page to get the latest version.
    </div>
    <h3>User profile</h3>
    <div id="userProfileDiv"></div>
    <br/>
    <select style="display: none" id="dfDropdown"></select>
    <br/>
    <small><a href="#" onclick="clearUserProfile()">Reset</a></small>
    <small><a href="#" onclick="importUserProfileTurtle()">Import</a></small>
    <small><a href="#" onclick="downloadUserProfileTurtle()">Export</a></small>
    <small><a href="#" onclick="showUserProfileTurtle()">Show Turtle</a></small>
    <h3>Missing data points</h3>
    <div>Set a focus:</div>
    <br/>
    <select id="focusInputSelectElement" multiple></select>
    <div class="loadingDiv">Loading...</div>
    <div id="missingDataPointsDiv"></div>
    <h3>Report</h3>
    <div class="loadingDiv">Loading...</div>
    <table id="reportTable"></table>

    <script>
        const element = document.getElementById("focusInputSelectElement")
        const focusInputSelect = new Choices(element, {
            removeItemButton: true,
            position: "bottom"
        })

        focusInputSelect.passedElement.element.addEventListener("addItem", async function() {
            focusInputSelect.hideDropdown()
            await buildPrioritizedMissingDataList()
        }, false)

        focusInputSelect.passedElement.element.addEventListener("removeItem", async function() {
            await buildPrioritizedMissingDataList()
        }, false)

        const EMPTY_PROFILE = { "@id": "ff:mainPerson", "@type": "ff:Citizen" }
        let userProfile
        let maxDepth = 0
        let latestRPsRepoCommit
        let turtleMap
        let metadata
        let validateAllReport
        let eligibleRPs

        async function parseTurtleFiles() {
            turtleMap = {
                "datafields": await fetchTextFile("requirement-profiles/datafields.ttl"),
                "materialization": await fetchTextFile("requirement-profiles/materialization.ttl"),
                "shacl": {}
            }
            let shaclFiles = await fetchTextFile("shacl-files.txt")
            for (let filename of shaclFiles.split("\n")) {
                if (!filename) continue
                turtleMap.shacl[filename] = await fetchTextFile("requirement-profiles/shacl/" + filename)
            }
            metadata = {
                df: await MatchingEngine.extractDatafieldsMetadata(turtleMap.datafields),
                rp: await MatchingEngine.extractRequirementProfilesMetadata(Object.values(turtleMap.shacl))
            }

            const selectEl = document.getElementById("dfDropdown")
            selectEl.innerHTML = ""
            for (let df of Object.values(metadata.df)) {
                const optionEl = document.createElement("option")
                optionEl.value = df.uri
                optionEl.textContent = df.label
                selectEl.appendChild(optionEl)
            }
            selectEl.addEventListener("change", function(event) {
                const selectedValue = event.target.value
                // TODO
            })

            console.log("metadata", metadata)
            buildFocusInputSelectChoices()
        }

        function buildFocusInputSelectChoices() {
            let categories = {}
            let rps = []
            for (let rp of Object.values(metadata.rp)) {
                rps.push({
                    value: rp.uri,
                    label: rp.title,
                })
                for (let cat of rp.categories) {
                    if (!categories[cat]) categories[cat] = []
                    categories[cat].push(rp.uri)
                }
            }
            metadata.categories = categories
            focusInputSelect.setChoices([
                {
                    label: "Categories",
                    choices: Object.keys(categories).map(uri => {
                        return {
                            value: uri,
                            label: uri.split("#")[1],
                        }
                    })
                },
                {
                    label: "Requirement Profiles",
                    choices: rps
                },
            ])
        }

        async function update() {
            await buildProfileTable()

            let userProfileTurtle = await MatchingEngine.convertUserProfileToTurtle(userProfile)
            console.log("userProfileTurtle", userProfileTurtle)
            validateAllReport = await MatchingEngine.validateAll(userProfileTurtle, turtleMap.shacl, turtleMap.datafields, turtleMap.materialization)
            console.log("validateAllReport", validateAllReport)

            let tableEl = document.getElementById("reportTable")
            tableEl.textContent = ""
            eligibleRPs = []

            for (let report of validateAllReport.reports) {
                if (report.result === "eligible") {
                    eligibleRPs.push(report.rpUri)
                }
                let tr = document.createElement("tr")
                let td = document.createElement("td")
                td.textContent = getRpTitle(report.rpUri)
                if (!metadata.rp[report.rpUri] || metadata.rp[report.rpUri].categories.length === 0) {
                    td.title = "No category info available"
                } else {
                    td.title = metadata.rp[report.rpUri].categories.map(cat => cat.split("#")[1]).join("\n")
                }
                tr.appendChild(td)
                td = document.createElement("td")
                td.textContent = report.result
                let msg = ""
                switch (report.result) {
                    case "eligible":
                        td.style.color = "green"
                        td.style.fontWeight = "bold"
                        msg += JSON.stringify(report.materializationReport) // TODO
                        break
                    case "ineligible":
                        td.style.color = "red"
                        for (let violation of report.violations) {
                            msg += violation.message + "\n"
                        }
                        break
                    case "undeterminable":
                        td.style.color = "gray"
                        msg += "Missing data points:\n"
                        for (let missing of report.missingUserInput) {
                            if (metadata.df[missing.dfUri]) {
                                msg += "- " + metadata.df[missing.dfUri].label + "\n"
                            }
                        }
                        break
                }
                td.title = msg
                tr.appendChild(td)
                td = document.createElement("td")
                td.style.fontSize = "x-small"
                td.style.color = "silver"
                td.innerHTML = "&nbsp;&nbsp;&nbsp;already getting this"
                td.addEventListener("click", async function() {
                    alert("TODO: " + report.rpUri)
                    // TODO
                })
                tr.appendChild(td)
                tableEl.appendChild(tr)
            }

            await buildPrioritizedMissingDataList()
        }

        async function buildPrioritizedMissingDataList() {
            let div = document.getElementById("missingDataPointsDiv")
            div.textContent = ""
            let prioritizedList = []

            let missingData = validateAllReport.missingUserInputsAggregated

            let focusRPs = []
            for (let focusItem of focusInputSelect.getValue(true)) {
                if (metadata.categories[focusItem]) {
                    focusRPs = focusRPs.concat(metadata.categories[focusItem])
                } else {
                    focusRPs.push(focusItem)
                }
            }

            for (let datafield of Object.values(missingData)) {

                let usedInRpUris = datafield.usedIn.map(usedInRP => usedInRP.rpUri)
                if (focusRPs.length > 0 && !usedInRpUris.some(rpUri => focusRPs.includes(rpUri))) {
                    continue
                }

                let usedInTitles = []
                let lastMissingCounter = 0
                for (let usedInRP of datafield.usedIn) {
                    usedInTitles.push(metadata.rp[usedInRP.rpUri].title + (usedInRP.isLastMissingUserInput ? " (!)" : ""))
                    if (usedInRP.isLastMissingUserInput) lastMissingCounter += 1
                }
                prioritizedList.push({
                    subject: datafield.subject,
                    dfUri: datafield.dfUri,
                    objectHasClass: metadata.df[datafield.dfUri]?.objectHasClass,
                    label: metadata.df[datafield.dfUri]?.label ?? datafield.dfUri.split("#")[1],
                    score: datafield.usedIn.length + lastMissingCounter,
                    usedInTitles: usedInTitles
                })
            }
            prioritizedList.sort((a, b) => b.score - a.score)
            prioritizedList.forEach((entry) => { // entry = wrapped datafield
                let spanEl = document.createElement("span")
                spanEl.title = entry.usedInTitles.join("\n")
                spanEl.style.color = "gray"
                let textNode = document.createTextNode(entry.score + ": ")
                spanEl.appendChild(textNode)
                div.appendChild(spanEl)
                let a = document.createElement("a")
                a.href = "#"
                a.textContent = entry.label
                a.addEventListener("click", async function(event) {
                    event.preventDefault()
                    if (entry.objectHasClass) {
                        if (confirm("Do you want to add a " + metadata.df[entry.objectHasClass].label + "?")) {
                            console.log("Adding object class instantiation:", entry.subject, entry.dfUri, "-->", entry.objectHasClass)
                            instantiateNewObjectClassUnderSubject(entry.subject, entry.dfUri, entry.objectHasClass)
                            await finalizeProfileChanges()
                        }
                        return
                    }
                    let input = prompt("What is your value for: " + entry.label)
                    if (input !== null) {
                        console.log("Adding entry:", entry.subject, entry.dfUri, "-->", input)
                        addEntryToSubject(entry.subject, entry.dfUri, input)
                        await finalizeProfileChanges()
                    }
                })
                div.appendChild(a)
                div.appendChild(document.createElement("br"))
            })
            for (const elem of Array.from(document.getElementsByClassName("loadingDiv"))) {
                elem.style.display = "none"
            }
        }

        function searchNodeRecursively(node, predicateValue, objectValue, action) {
            for (let [predicate, objectOrArray] of Object.entries(node)) {
                console.log("looking at ", objectOrArray, objectValue)
                if (objectValue && objectOrArray === objectValue) { // e.g. ff:child0 as the value, key would be @id
                    action(node)
                }
                if (predicateValue && predicate === predicateValue) { // e.g. ff:hasChild as the key
                    action(node)
                }
                if (Array.isArray(objectOrArray)) {
                    for (let arrayEl of objectOrArray) {
                        searchNodeRecursively(arrayEl, predicateValue, objectValue, action)
                    }
                }
            }
        }

        function addEntryToSubject(subject, predicate, objectValue) {
            subject = "ff:" + subject.split("#")[1]
            predicate = "ff:" + predicate.split("#")[1]
            searchNodeRecursively(userProfile, null, subject, (node) => {
                node[predicate] = objectValue
            })
        }

        function instantiateNewObjectClassUnderSubject(subject, predicate, objectClass) {
            let shortObjectClassUri = shortenLongUri(objectClass)
            searchNodeRecursively(userProfile, predicate, null, (node) => {
                let newInstanceUri = shortObjectClassUri.toLowerCase()
                if (node) {
                    node[predicate].push({ "@id": newInstanceUri + node[predicate].length, "@type": shortObjectClassUri }) // verify that this works TODO
                } else { // e.g. no ff:hasChild array yet
                    addEntryToSubject(subject, predicate, [{ "@id": newInstanceUri + "0", "@type": shortObjectClassUri }])
                }
            })
        }

        async function finalizeProfileChanges() {
            // profile validation / maybe materialization suggestions too? TODO
            console.log("userProfile", userProfile)
            localStorage.setItem("userProfile", JSON.stringify(userProfile))
            await update()
        }

        function buildProfileTableRecursively(node, depth, table) {
            for (let [predicate, objectOrArray] of Object.entries(node)) {
                if (predicate.startsWith("@")) continue
                if (!Array.isArray(objectOrArray)) {
                    let tds = buildRowAndColumns(table)
                    let label = dfShortUriToLabel(predicate)
                    tds[depth].textContent = label
                    tds[depth + 1].textContent = objectOrArray
                    tds[depth + 1].addEventListener("click", async function() {
                        let input = prompt(`Enter new value for ${label}`)
                        if (input !== null) {
                            // TODO
                        }
                    })
                    tds[maxDepth + 2].textContent = "x"
                    tds[maxDepth + 2].addEventListener("click", async function() {
                        if (confirm("Do you want to remove this entry?")) {
                            // TODO
                        }
                    })
                    continue
                }
                for (let arrayElement of objectOrArray) {
                    let tds = buildRowAndColumns(table)
                    let label = dfShortUriToLabel(predicate)
                    tds[depth].textContent = label
                    tds[maxDepth + 2].textContent = "x"
                    tds[maxDepth + 2].addEventListener("click", async function() {
                        if (confirm(`Do you want to remove this entire ${label}?`)) {
                            // TODO
                        }
                    })
                    buildProfileTableRecursively(arrayElement, depth + 1, table)
                }
            }
        }

        // this is needed to know the correct number of columns in the profile table in advance
        function determineDepthOfProfileTreeRecursively(jsonNode, depth) {
            if (depth > maxDepth) maxDepth = depth
            for (let objectOrArray of Object.values(jsonNode)) {
                if (!Array.isArray(objectOrArray)) continue
                for (let arrayElement of objectOrArray) determineDepthOfProfileTreeRecursively(arrayElement, depth + 1)
            }
        }

        function buildProfileTable() {
            let div = document.getElementById("userProfileDiv")
            div.innerHTML = ""
            let table = document.createElement("table")
            table.className = "framed-table"
            div.appendChild(table)
            maxDepth = 0
            determineDepthOfProfileTreeRecursively(userProfile, 0)
            buildProfileTableRecursively(userProfile, 0, table)
        }

        async function run() {
            if (localStorage.getItem("userProfile") === null) {
                localStorage.setItem("userProfile", JSON.stringify(EMPTY_PROFILE))
            }
            userProfile = JSON.parse(localStorage.getItem("userProfile"))
            latestRPsRepoCommit = await fetchTextFile("latest-rps-repo-commit.txt")
            await parseTurtleFiles()
            await update()
            setInterval(checkForNewRepoCommits, 60 * 1000)
        }

        run()

        // ----- utils ----

        async function checkForNewRepoCommits() {
            console.log("Checking for updates, old commit:", latestRPsRepoCommit)
            let checkLatestRPsRepoCommit = await fetchTextFile("latest-rps-repo-commit.txt")
            // TODO also check foerderfunke-webapp latest commit
            if (checkLatestRPsRepoCommit === latestRPsRepoCommit) return
            console.log("Update available, new commit:", checkLatestRPsRepoCommit)
            latestRPsRepoCommit = checkLatestRPsRepoCommit
            document.getElementById("update-banner").style.display = "block"
            let eligibleRPsBefore = [... eligibleRPs]
            await parseTurtleFiles()
            await update()
            let newEligibleRPs = eligibleRPs.filter(rp => !eligibleRPsBefore.includes(rp))
            if (newEligibleRPs.length > 0) {
                document.title = `(${newEligibleRPs.length}) ${document.title}`
                alert("New eligible requirement profiles available: " + newEligibleRPs.map(rpUri => getRpTitle(rpUri)).join(", "))
            }
        }

        function dfShortUriToLabel(key) {
            return metadata.df[expandShortUri(key)]?.label ?? key
        }

        function expandShortUri(uri) {
            return uri.startsWith("ff:") ? "https://foerderfunke.org/default#" + uri.slice(3) : uri
        }

        function shortenLongUri(uri) {
            return uri.startsWith("http") ? "ff:" + uri.split("#")[1] : uri
        }

        function buildRowAndColumns(table) {
            let tr = document.createElement("tr")
            table.appendChild(tr)
            let tds = []
            for (let i = 0; i < maxDepth + 3; i++) {
                let td = document.createElement("td")
                tr.appendChild(td)
                tds.push(td)
            }
            return tds
        }

        function getRpTitle(rpUri) {
            return metadata.rp[rpUri]?.title ?? rpUri
        }

        async function fetchTextFile(relPath) {
            const response = await fetch(relPath, {
                method: "GET",
                cache: "reload"
            })
            return await response.text()
        }

        async function clearUserProfile() {
            localStorage.clear()
            userProfile = EMPTY_PROFILE
            localStorage.setItem("userProfile", JSON.stringify(userProfile))
            await update()
        }

        async function importUserProfileTurtle() {
            alert("TODO")
            // TODO
        }

        async function downloadUserProfileTurtle() {
            let userProfileTurtle = await MatchingEngine.convertUserProfileToTurtle(userProfile)
            let blob = new Blob([userProfileTurtle], {type: "text/turtle"})
            let url = URL.createObjectURL(blob)
            let a = document.createElement("a")
            a.href = url
            a.download = "user-profile.ttl"
            document.body.appendChild(a)
            a.click()
            document.body.removeChild(a)
            window.URL.revokeObjectURL(url)
        }

        async function showUserProfileTurtle() {
            let userProfileTurtle = await MatchingEngine.convertUserProfileToTurtle(userProfile)
            alert(userProfileTurtle)
        }
    </script>
</body>
</html>
